# -*- coding: utf-8 -*-
"""Production Stockout Calculation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JKrbkWG9hSEqSpoMrSyBUT9dqkh5fRt3
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import os
import tqdm
from google.colab import files

# Function to show progress
def progress_bar(step, total_steps):
    print(f"Step {step}/{total_steps} completed...")

# Step 1: Identify Files in the Runtime Storage
files_list = os.listdir()

# Identify the filenames
availability_file = next(f for f in files_list if "AvailabilityReport" in f)
inventory_file = next(f for f in files_list if "InventoryList" in f)
bom_file = next(f for f in files_list if "BOM" in f)

total_steps = 8  # Reduce step count for clarity

# Step 2: Read CSV files using efficient dtypes (as per user preference)
availability_df = pd.read_csv(availability_file, usecols=["SKU", "OnHand", "OnOrder"])
inventory_df = pd.read_csv(inventory_file, usecols=["ProductCode", "AverageCost"])
bom_df = pd.read_csv(bom_file, usecols=["SKU", "SUM of Quantity Per PCB"])

# Convert column names for consistency
inventory_df.rename(columns={"ProductCode": "SKU"}, inplace=True)
bom_df.rename(columns={"SUM of Quantity Per PCB": "Required_Qty_Per_Unit"}, inplace=True)

# Ensure SKUs are treated as strings and drop NaN values
bom_skus = set(bom_df["SKU"].dropna().astype(str))

# Filter inventory to keep only SKUs that appear in the BOM file
filtered_inventory_df = inventory_df[inventory_df["SKU"].isin(bom_skus)]

# Verify the filtered data
print("Filtered Inventory List (Only SKUs in BOM):")
print(filtered_inventory_df.head())
print(f"Filtered Inventory List shape: {filtered_inventory_df.shape}")  # (rows, columns)

# Filter availability to keep only SKUs that appear in the BOM file
filtered_availability_df = availability_df[availability_df["SKU"].isin(bom_skus)]

# Verify the filtered data
print("Filtered Availability List (Only SKUs in BOM):")
print(filtered_availability_df.head())
print(f"Filtered Availability List shape: {filtered_availability_df.shape}")  # (rows, columns)

# Convert numerical columns to efficient types
filtered_availability_df.fillna(0, inplace=True) # fill missing data with zeros in availability data
filtered_availability_df[["OnHand", "OnOrder"]] = filtered_availability_df[["OnHand", "OnOrder"]].astype(np.int32)  # QTYs require only integers (optimise performance)

bom_df["Required_Qty_Per_Unit"].fillna(0, inplace=True) # Fill NaN values with 0 before converting to int32
bom_df["Required_Qty_Per_Unit"] = bom_df["Required_Qty_Per_Unit"].astype(np.int32)  # QTYs require only integers (optimise performance)
print(f"BOM shape: {bom_df.shape}")  # (rows, columns)

filtered_inventory_df["AverageCost"] = filtered_inventory_df["AverageCost"].astype(np.float32)  # Costs require decimals

# Group by SKU to sum OnHand and OnOrder across all warehouse locations
filtered_availability_df = filtered_availability_df.groupby("SKU", as_index=False).agg({
    "OnHand": "sum",
    "OnOrder": "sum"
})

# Print first 5 rows of each dataframe
# Verify aggregation
print("📌 Aggregated Availability DataFrame (Summed Across Warehouses):")
print(filtered_availability_df.head())
print(f"Filtered & Aggregated Availability List shape: {filtered_availability_df.shape}")  # (rows, columns)

print("📌 Inventory DataFrame:")
print(filtered_inventory_df.head(), "\n")

print("📌 BOM DataFrame:")
print(bom_df.head(), "\n")

# Ensure SKUs are treated as strings and drop NaN values
inventory_skus = set(filtered_inventory_df["SKU"].dropna().astype(str))  # Inventory SKUs
availability_skus = set(filtered_availability_df["SKU"].dropna().astype(str))  # Availability SKUs
bom_skus = set(bom_df["SKU"].dropna().astype(str))  # BOM SKUs

# Find SKUs in inventory file that are missing AverageCosts
missing_avg_cost_skus = filtered_inventory_df[filtered_inventory_df["AverageCost"].isna()]
# Print missing SKUs
if not missing_avg_cost_skus.empty:
    print("🔴 SKUs missing average costs from Inventory List:")
    print(missing_avg_cost_skus)
else:
    print("✅ No SKUs in BOM are missing average costs.")

# Find SKUs in BOM that are missing from the Inventory file
missing_from_inventory = bom_skus - inventory_skus
# Print missing SKUs
if missing_from_inventory:
    print("🔴 SKUs in BOM but missing from Inventory List:", missing_from_inventory)
else:
    print("✅ No SKUs in BOM are missing from the Inventory List.")

# Find SKUs in BOM that are missing from the Availability file
missing_from_availability = bom_skus - availability_skus
if missing_from_availability:
    print("🔴 SKUs in BOM but missing from Availability List:", missing_from_availability)
else:
    print("✅ No SKUs in BOM are missing from the Availability List.")

progress_bar(1, total_steps)

# Sort the inventory data by AverageCost in descending order
sorted_inventory_df = filtered_inventory_df.sort_values(by="AverageCost", ascending=False)
print(f"Sorted Inventory List shape: {sorted_inventory_df.shape}")  # (rows, columns)

# Create an interactive bar chart for SKU Average Costs
fig = px.bar(sorted_inventory_df, x="SKU", y="AverageCost",
             title="SKU Average Cost Distribution",
             labels={"ProductCode": "SKU", "AverageCost": "Average Cost"},
             template="plotly_dark")

# Show the interactive bar chart
fig.show()

# Step 3: Create Merged Data using only BOM SKUs and Sum Data
merged_df = (
    bom_df
    .merge(filtered_availability_df, on="SKU", how="left")  # Merge with filtered availability data
    .merge(filtered_inventory_df, on="SKU", how="left")  # Merge with filtered inventory data
)

# Fill NaN values with zero before conversion
merged_df.fillna({"OnHand": 0, "OnOrder": 0, "Required_Qty_Per_Unit": 0, "AverageCost": 0}, inplace=True)

# Convert to efficient dtypes
merged_df = merged_df.astype({
    "OnHand": "int32",
    "OnOrder": "int32",
    "Required_Qty_Per_Unit": "int32",
    "AverageCost": "float32"
})

# Compute total stock by summing across entries
merged_df["Total_Stock"] = merged_df["OnHand"] + merged_df["OnOrder"]
print(f"Merged Data shape: {merged_df.shape}")  # (rows, columns)

# Print first 5 rows of each dataframe
print("📌 Merged DataFrame:")
print(merged_df.dtypes, "\n", merged_df.head(), "\n")

# ✅ Now, stock_out_df will use the **correct summed stock values**
unit_range = np.arange(0, 10000, dtype=np.int32)  # Limit QTY
stock_out_array = merged_df["Total_Stock"].values[:, None] - (unit_range * merged_df["Required_Qty_Per_Unit"].values[:, None])
stock_out_df = pd.DataFrame(stock_out_array.T, index=unit_range, columns=merged_df["SKU"])
print(f"Stock Out shape: {stock_out_df.shape}")  # (rows, columns)

# ✅ Save Stock-Out Data in Wide Format (No Duplicates)
stock_out_df.to_csv("Stock_Out.csv")  # No `melt()`, keeps one row per unit produced
print("Stock_Out.csv saved.")

# ORIGINAL
# 🔹 Convert to long-form ONLY for Plotly visualization
stock_out_long_df = stock_out_df.reset_index().melt(id_vars="index", var_name="SKU", value_name="Remaining Stock")
stock_out_long_df.rename(columns={"index": "Units Produced"}, inplace=True)
print(f"Stock Out Long shape: {stock_out_long_df.shape}")  # (rows, columns)

# 🔹 **Optimized Plotting: Use WebGL for Large SKU Datasets**
fig = px.scatter(stock_out_long_df, x="Units Produced", y="Remaining Stock", color="SKU",
                 title="Stock Depletion Over Production (Optimized WebGL)",
                 labels={"Units Produced": "Units Produced", "Remaining Stock": "Remaining Stock"},
                 template="plotly_dark",
                 render_mode="webgl")  # Uses WebGL for better performance

fig.show()

# OPTION 1
# import numpy as np

# # Apply log transformation while preserving negatives
# stock_out_long_df["Log Remaining Stock"] = np.sign(stock_out_long_df["Remaining Stock"]) * np.log1p(abs(stock_out_long_df["Remaining Stock"]))

# # Plot with transformed y-axis
# fig = px.scatter(stock_out_long_df, x="Units Produced", y="Log Remaining Stock", color="SKU",
#                  title="Stock Depletion Over Production (Log Adjusted for Negatives)",
#                  labels={"Units Produced": "Units Produced", "Log Remaining Stock": "Log(1+|Remaining Stock|)"},
#                  template="plotly_dark",
#                  render_mode="webgl")

# fig.show()

import numpy as np

# Apply log transformation while preserving negatives
stock_out_long_df["Log Remaining Stock"] = np.sign(stock_out_long_df["Remaining Stock"]) * np.log1p(abs(stock_out_long_df["Remaining Stock"]))

# Ensure no NaN values in the dataset before calculating tick values
valid_values = stock_out_long_df["Remaining Stock"].dropna()

# Compute tick values based on percentiles (min, 25%, median, 75%, max)
if not valid_values.empty:
    quantiles = valid_values.quantile([0, 0.25, 0.5, 0.75, 1]).dropna().values  # Only 5 representative values
    tickvals = np.sign(quantiles) * np.log1p(abs(quantiles))  # Apply log scaling only on these values
else:
    tickvals = [0]  # Fallback if dataset is empty

# Convert back to original values for labels
ticktext = [f"{int(np.sign(t) * np.expm1(abs(t)))}" for t in tickvals]

# Create the plot
fig = px.scatter(stock_out_long_df, x="Units Produced", y="Log Remaining Stock", color="SKU",
                 title="Stock Depletion Over Production (Log Adjusted for Negatives)",
                 labels={"Units Produced": "Units Produced", "Log Remaining Stock": "Remaining Stock"},
                 template="plotly_dark",
                 render_mode="webgl")

# Update y-axis with representative labels
fig.update_layout(yaxis=dict(
    tickmode="array",
    tickvals=tickvals.tolist(),
    ticktext=ticktext
))

fig.show()

# OPTION 2
# Apply symlog transformation
import numpy as np
def symlog_transform(y, lin_thresh=10):
    return np.sign(y) * np.log1p(abs(y) / lin_thresh)

stock_out_long_df["Symlog Remaining Stock"] = stock_out_long_df["Remaining Stock"].apply(lambda y: symlog_transform(y))

fig = px.scatter(stock_out_long_df, x="Units Produced", y="Symlog Remaining Stock", color="SKU",
                 title="Stock Depletion Over Production (Symlog Scale)",
                 labels={"Units Produced": "Units Produced", "Symlog Remaining Stock": "Symlog Remaining Stock"},
                 template="plotly_dark",
                 render_mode="webgl")

fig.show()

# OPTION 3

# Get min and max values
y_min, y_max = stock_out_long_df["Remaining Stock"].min(), stock_out_long_df["Remaining Stock"].max()

# Generate tick values dynamically
neg_ticks = np.linspace(y_min, 0, num=5) if y_min < 0 else []
pos_ticks = np.logspace(0, np.log10(y_max), num=5) if y_max > 0 else []

# Combine and round
tickvals = np.concatenate((neg_ticks, pos_ticks))
tickvals = np.round(tickvals, decimals=2)  # Keep it readable

# Generate tick labels
ticktext = [str(int(t)) if abs(t) >= 1 else f"{t:.2f}" for t in tickvals]

# Create the plot
fig = px.scatter(stock_out_long_df, x="Units Produced", y="Remaining Stock", color="SKU",
                 title="Stock Depletion Over Production (Auto-Scaled Y-Axis)",
                 labels={"Units Produced": "Units Produced", "Remaining Stock": "Remaining Stock"},
                 template="plotly_dark",
                 render_mode="webgl")

# Update y-axis with dynamic scaling
fig.update_layout(yaxis=dict(
    tickmode="array",
    tickvals=tickvals.tolist(),
    ticktext=ticktext
))

fig.show()

progress_bar(3, total_steps)

# Print first 5 elements of unit_range (as it's a NumPy array)
print("📌 Unit Range (NumPy Array):")
print(unit_range[:5], "\n")

print("📌 Stock-Out DataFrame:")
print(stock_out_df.dtypes, "\n", stock_out_df.head(), "\n")

print("📌 Stock-Out Long DataFrame (For Plotly):")
print(stock_out_long_df.dtypes, "\n", stock_out_long_df.head(), "\n")

progress_bar(4, total_steps)

# Step 1: Replace all positive values in stock_out_df with 0
stock_replenishment_df = stock_out_df.copy()
stock_replenishment_df[stock_replenishment_df > 0] = 0

# Step 2: Convert all values to absolute (positive) values
stock_replenishment_df = stock_replenishment_df.abs()

# Step 3: Plot stock_replenishment_df on a log scale graph
fig = px.line(stock_replenishment_df,
              title="Stock Replenishment Needs (Log Scale)",
              labels={"index": "Units Produced", "value": "Stock Needed"},
              template="plotly_dark")

# Apply logarithmic scale to the y-axis
fig.update_layout(yaxis_type="log")

# Show the graph
fig.show()

# Save the transformed data for reference
stock_replenishment_df.to_csv("Stock_Replenishment.csv")
print("Stock_Replenishment.csv saved.")

# Step 6: Calculate Stock Replenishment Costs (Vectorized)
costs = merged_df.set_index("SKU")["AverageCost"]

# Apply costs only when stock is negative
stock_out_cost_df = np.where(stock_out_df < 0, np.abs(stock_out_df) * costs, 0)
stock_out_cost_df = pd.DataFrame(stock_out_cost_df, index=unit_range, columns=merged_df["SKU"])
print(f"Stock Out Cost shape: {stock_out_cost_df.shape}")  # (rows, columns)

progress_bar(5, total_steps)

# Save Stock Replenishment Cost Data
stock_out_cost_df.to_csv("Stock_Out_Cost.csv")
print("Stock_Out_Cost.csv saved.")

# Step 7: Cumulative Cost Calculation (Fixed: Use direct values instead of cumsum)
cumulative_costs_df = stock_out_cost_df.copy()
print(f"Cumulative Costs shape: {cumulative_costs_df.shape}")  # (rows, columns)

# Save Cumulative Costs Data
cumulative_costs_df.to_csv("Cumulative_Costs.csv")
print("Cumulative_Costs.csv saved.")

progress_bar(6, total_steps)

# 🔹 **Stacked Graph for Cumulative Costs (Optimized)**
fig = go.Figure()

for sku in cumulative_costs_df.columns:
    fig.add_trace(go.Scatter(x=cumulative_costs_df.index, y=cumulative_costs_df[sku],
                             stackgroup='one', mode="lines", name=sku))

fig.update_layout(title="Cumulative Cost Per SKU Over Production (Stacked, Optimized)",
                  xaxis_title="Units Produced",
                  yaxis_title="Cumulative Replenishment Cost",
                  template="plotly_dark")

fig.show()

progress_bar(7, total_steps)

# Step 8: Sum All SKU Costs Incrementally
total_cumulative_costs = cumulative_costs_df.sum(axis=1)

# Save Total Cumulative Cost Data
total_cumulative_costs.to_csv("Total_Cumulative_Costs.csv")
print("Total_Cumulative_Costs.csv saved.")

# 🔹 **Optimized Final Cumulative Cost Plot**
fig = px.line(x=total_cumulative_costs.index, y=total_cumulative_costs,
              title="Total Cumulative Replenishment Cost Over Production (Optimized)",
              labels={"x": "Units Produced", "y": "Total Cumulative Cost"},
              template="plotly_dark",
              render_mode="webgl")  # WebGL for better performance

fig.show()

progress_bar(8, total_steps)

print("All steps completed successfully. ✅")

# List of generated CSV files
csv_files = ["Stock_Out.csv", "Stock_Replenishment.csv", "InventoryList_2025-03-15.csv", "Stock_Out_Cost.csv", "Total_Cumulative_Costs.csv", "AvailabilityReport_2025-03-15.csv", "Cumulative_Costs.csv","[IMP] HB Lite BOM v3.5.2.csv"]

# Print file sizes in KB
print(f"File Size [KB]")
for file in csv_files:
    if os.path.exists(file):
        size_kb = os.path.getsize(file) / 1024  # Convert bytes to KB
        print(f"{size_kb:.2f}\t📂 {file}")
    else:
        print(f"⚠️ {file} not found.")